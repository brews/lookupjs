<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<link rel="stylesheet" href="style.css" type="text/css">
	<title>lookup</title>
	<script src="d3.v3.min.js", type="text/javascript"></script>
	<script src="lookup.js" type="text/javascript"></script>
</head>

<body>
	<div id="container">
		<div id="timeline-chart">
			timeline-chart
		</div>
		<div id="series-chart">
			series-chart
		</div>
		<div id="shortresult-chart">
			shortresult-chart
		</div>
		<div id="longresult-chart">
			longresult-chart
		</div>
				<!-- filterform is just a holder until I get a proper filter graphic up -->
		<div id="filterform">
			<div class="seriesfilterforms">
				<h3 align="center">Series 1</h3>
				<form class="filterform">
	 				<legend>Year 1</legend>
	 				<p>Minimum: <input name="seriesname1Year1Min" type="number" min="0" max = "10" value="5"></p>
	 				<p>Maximum: <input name="seriesname1Year1Max" type="number" min="0" max = "10" value="5"></p>
	 			</form>
	 			<form class="filterform">
	 				<legend>Year 2</legend>
	 				<p>Minimum: <input name="seriesname1Year2Min" type="number" min="0" max = "10" value="5"></p>
	 				<p>Maximum: <input name="seriesname1Year2Max" type="number" min="0" max = "10" value="5"></p>
	 			</form>
	 			<form class="filterform">
	 				<legend>Year 3</legend>
	 				<p>Minimum: <input name="seriesname1Year3Min" type="number" min="0" max = "10" value="5"></p>
	 				<p>Maximum: <input name="seriesname1Year3Max" type="number" min="0" max = "10" value="5"></p>
	 			</form>
	 		</div>
	 		<div class="seriesfilterforms">
				<h3 align="center">Series 2</h3>
				<form class="filterform">
	 				<legend>Year 1</legend>
	 				<p>Minimum: <input name="seriesname2Year1Min" type="number" min="0" max = "10" value="5"></p>
	 				<p>Maximum: <input name="seriesname2Year1Max" type="number" min="0" max = "10" value="5"></p>
	 			</form>
	 			<form class="filterform">
	 				<legend>Year 2</legend>
	 				<p>Minimum: <input name="seriesname2Year2Min" type="number" min="0" max = "10" value="5"></p>
	 				<p>Maximum: <input name="seriesname2Year2Max" type="number" min="0" max = "10" value="5"></p>
	 			</form>
	 			<form class="filterform">
	 				<legend>Year 3</legend>
	 				<p>Minimum: <input name="seriesname2Year3Min" type="number" min="0" max = "10" value="5"></p>
	 				<p>Maximum: <input name="seriesname2Year3Max" type="number" min="0" max = "10" value="5"></p>
	 			</form>
	 		</div>
		</div>
	</div>
	<script type="text/javascript">

	var dataset = [];
	var windowpane = {};  // Should have "low" and "high", assumed to correspond to years in the series.

	// var drag = d3.behavior.drag()
	// 	.origin(Object)
	// 	.on("drag", dragwindow);

	// function dragwindow(d) {
	// 	// d3.select(this)
	// 	// 	.append("rect")
	// 	// 	.attr("class", "windowpane")
	// 	// 	.x(0)
	// 	// 	.y(x.event)
	// 	// 	.height()
	// 	// 	.width();
	// 	console.log(d3.event)  // DEBUG
	// }

	var timelineMargin = {top: 20, right: 50, bottom: 20, left: 50};
	var timelineWidth = 660 - timelineMargin.left - timelineMargin.right;
	var timelineHeight = 300 - timelineMargin.top - timelineMargin.bottom;
	var timelinexScale = d3.scale.linear();
	var timelineyScale = d3.scale.linear();
	var timelinexAxis = d3.svg.axis();
	var timelineyAxis = d3.svg.axis();

	d3.csv("riverclimate.csv", function(error, data) {
		// TODO: Still need some error catching here.
		if (error) {
			console.log(error);
		} else {
			data.forEach(function(d, index) {
				// Convert strings to numbers and assign to `dataset`.
				var dkeys = d3.keys(d);
				var outgoing = {};
				for (var i = 0; i < dkeys.length; i++) {
					outgoing[dkeys[i]] = +d[dkeys[i]];
				}
				dataset[index] = outgoing;
			});
		// console.log(dataset); // DEBUG
		}

		// Awesome vis code here.

		// Plotting the timeline.
		timelineyScale.domain([d3.min(dataset, function(d) { return d["FourRivers"]; }),
								d3.max(dataset, function(d) { return d["FourRivers"]; })])
			.range([timelineHeight, 0]);
		timelinexScale.domain([d3.min(dataset, function(d) { return d["Year"]; }),
								d3.max(dataset, function(d) { return d["Year"]; })])
			.range([0, timelineWidth]);
		timelineyAxis.scale(timelineyScale)
			.orient("left")
			.tickFormat(d3.format("d"));
		timelinexAxis.scale(timelinexScale)
			.orient("bottom")
			.tickFormat(d3.format("d"));

		var timelineLine = d3.svg.line() // I think we're going to need this to be global.
			.x(function(d) { return timelinexScale(d["Year"]); })
			.y(function(d) { return timelineyScale(d["FourRivers"]); });

		var timelineSvg = d3.select("#timeline-chart").append("svg")
			.attr("width", timelineWidth + timelineMargin.left + timelineMargin.right)
			.attr("heigh", timelineHeight + timelineMargin.top + timelineMargin.bottom)

		timelineSvg.append("g")
				.attr("id", "timelineplotspace")
				.attr("transform", "translate(" + timelineMargin.left + "," + timelineMargin.top + ")");

		function drawWindowPane(obj) {
			// Draws and updates the timeline's window pane.
			lowscaled = timelinexScale(windowpane.low);
			highscaled = timelinexScale(windowpane.high);
			windowwidth = highscaled - lowscaled;
			timelineSvg.select(".windowpane")
				.attr("x", lowscaled)
				.attr("y", 0)
				.attr("width", windowwidth)
				.attr("height", timelineHeight)
				.attr("class", "windowpane");
		}

		// The rect makes it so we can catch mouseup & down events.
		timelineSvg.select("#timelineplotspace").append("rect")
				.attr("x", 0)
				.attr("y", 0)
				.attr("width", timelineWidth)
				.attr("height", timelineHeight)
				.attr("fill", "white")
				.on("mousedown", function() {
					x = timelinexScale.invert(d3.event.x - timelineMargin.left);
					windowpane.low = d3.round(x);
					drawWindowPane(this);
				})
				.on("mouseup", function() {
					x = timelinexScale.invert(d3.event.x - timelineMargin.left);
					windowpane.high = d3.round(x);
					drawWindowPane(this);
				});

		timelineSvg.select("#timelineplotspace").append("path")
			.attr("class", "lineplot lineplotpath")
			.attr("d", timelineLine(dataset));

		timelineSvg.select("#timelineplotspace").selectAll("circle")
			.data(dataset)
			.enter()
			.append("circle")
			.attr("class", "lineplot")
			.attr("cy", function(d) {
				return timelineyScale(d["FourRivers"]);
			})
			.attr("cx", function(d) {
				return timelinexScale(d["Year"]);
			})
			.attr("r", 2)
			.append("title")
			.text(function(d) {
				return d["FourRivers"] + " (" + d["Year"] + ")";
			});

		timelineSvg.select("#timelineplotspace").append("g")
			.attr("class", "axis")
			.attr("transform", "translate(0," + timelineHeight + ")")
			.call(timelinexAxis);
		timelineSvg.select("#timelineplotspace").append("g")
			.attr("class", "axis")
			.call(timelineyAxis);

		timelineSvg.select("#timelineplotspace").append("rect")
					.attr("class", "windowpane");

	});
	console.log(dataset);
	/////////////////////////////////////////////////////
	// TODO: Get basic timeline plot with highlighting mechanism then work 
	//       out the filter design.
	/////////////////////////////////////////////////////

	</script>
</body>
</html>