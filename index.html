<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>Lookupjs by brews</title>

    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/pygment_trac.css">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="wrapper">
      <header>
        <h1>Lookupjs</h1>
        <p>A tool to visually match short patterns across multiple time series. This is the HTML implementation.</p>

        <p class="view"><a href="https://github.com/brews/lookupjs">View the Project on GitHub <small>brews/lookupjs</small></a></p>


        <ul>
          <li><a href="https://github.com/brews/lookupjs/zipball/master">Download <strong>ZIP File</strong></a></li>
          <li><a href="https://github.com/brews/lookupjs/tarball/master">Download <strong>TAR Ball</strong></a></li>
          <li><a href="https://github.com/brews/lookupjs">View On <strong>GitHub</strong></a></li>
        </ul>
      </header>
      <section>
        <h1>
<a name="lookup" class="anchor" href="#lookup"><span class="octicon octicon-link"></span></a>lookup</h1>

<p>A tool to visually match short patterns across multiple time series.</p>
        <div id="container">
          <div id="timeline-chart">
            <div class="title">timeline</div>
          </div>
          <div id="filter-chart">
            <div class="title">filter</div>
          </div>
          <div id="yearhist-chart">
            <div class="title">single-year histogram</div>
          </div>
        </div>
      </section>
      <footer>
        <p>This project is maintained by <a href="https://github.com/brews">brews</a></p>
        <p><small>Hosted on GitHub Pages &mdash; Theme by <a href="https://github.com/orderedlist">orderedlist</a></small></p>
      </footer>
    </div>
    <script src="javascripts/scale.fix.js"></script>
    <script src="javascripts/d3.v3.min.js", type="text/javascript"></script>
    <script src="javascripts/lookup.js" type="text/javascript"></script>
    <script type="text/javascript">
      var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
      document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
    </script>
    <script type="text/javascript">
      try {
        var pageTracker = _gat._getTracker("UA-42669371-1");
        pageTracker._trackPageview();
      } catch(err) {}
    </script>
      <script type="text/javascript">

      var dataset = [];
      var yearhistData = {};
      var highlight = []; // To be an array giving years to be highlighted.
      var seriespadding = 12;  // Padding between each of the plotted time series in timeline.
      var noseries = 3; // TODO: Number of series we are plotting, this shouldn't be a magic number.
      // Axis and bin ticks.
      var fourriversTicks = 5;
      var leesferryTicks = 5;
      var pnaTicks = 5;
      var filterXAxisTicks = 3;
      // var yearhistXAxisTicks = 3;

      var timelineMargin = {top: 20, right: 50, bottom: 20, left: 50};
      var timelineWidth = 660 - timelineMargin.left - timelineMargin.right;
      var timelineHeight = 300 - timelineMargin.top - timelineMargin.bottom;
      var timelineXScale = d3.scale.linear();
      var timelineFourRiversYScale = d3.scale.linear();
      var timelineLeesFerryYScale = d3.scale.linear();
      var timelinePNAYScale = d3.scale.linear();
      var timelineXAxis = d3.svg.axis();
      var timelineFourRiversYAxis = d3.svg.axis();
      var timelineLeesFerryYAxis = d3.svg.axis();
      var timelinePNAYAxis = d3.svg.axis();

      var previousScale = 1;  // This is so that we can differentiate zoom-panning from the actual zoom and use transitions accordingly in `zoomer()`.

      function highlightYears(x) {
        // To highlight obs in an array of years, d, in timeline-chart.
        d3.selectAll(".lineplotcircle.highlight").attr("class", "lineplot lineplotcircle");
        d3.selectAll(".lineplotcircle").filter(function(d) { return x.indexOf(d.Year) === -1 ? null : true; })
          .transition()
          .attr("class", "lineplot lineplotcircle highlight");
      }

      function initYearhistData() {
        // Initialize the YearHistData object before a filter has actually been created.
        // yearhistData.FourRivers = [];
        // yearhistData.LeesFerry = [];
        // yearhistData.PNA = [];
        yearhistData.FourRivers = d3.layout.histogram()
          .bins(timelineFourRiversYScale.ticks(fourriversTicks))
          (dataset.map(function(d) { return d.FourRivers; }));
        yearhistData.LeesFerry = d3.layout.histogram()
          .bins(timelineLeesFerryYScale.ticks(leesferryTicks))
          (dataset.map(function(d) { return d.LeesFerry; }));
        yearhistData.PNA = d3.layout.histogram()
          .bins(timelinePNAYScale.ticks(pnaTicks))
          (dataset.map(function(d) { return d.PNA; }));
      }

      d3.csv("riverclimate.json", function(error, data) {
        // TODO: Still need some error catching here.
        if (error) {
          console.log(error);
        } else {
          data.forEach(function(d, index) {
            // Convert strings to numbers and assign to `dataset`.
            var dkeys = d3.keys(d);
            var outgoing = {};
            for (var i = 0; i < dkeys.length; i++) {
              outgoing[dkeys[i]] = +d[dkeys[i]];
            }
            dataset[index] = outgoing;
          });
        // console.log(dataset); // DEBUG
        lookup.setData(dataset);
        }

        //// Awesome vis code here. //
        // Plotting the timeline.
        var serieschartHeight = timelineHeight / noseries - seriespadding;
        timelineFourRiversYScale.domain([d3.min(dataset, function(d) { return d["FourRivers"]; }),
                    d3.max(dataset, function(d) { return d["FourRivers"]; })])
          .range([serieschartHeight, 0])
          .nice(fourriversTicks);
        timelineLeesFerryYScale.domain([d3.min(dataset, function(d) { return d["LeesFerry"]; }),
                    d3.max(dataset, function(d) { return d["LeesFerry"]; })])
          .range([serieschartHeight, 0])
          .nice(leesferryTicks);
        timelinePNAYScale.domain([d3.min(dataset, function(d) { return d["PNA"]; }),
                    d3.max(dataset, function(d) { return d["PNA"]; })])
          .range([serieschartHeight, 0]);
        timelineXScale.domain([d3.min(dataset, function(d) { return d["Year"]; }),
                    d3.max(dataset, function(d) { return d["Year"]; })])
          .range([0, timelineWidth]);

        var zoom = d3.behavior.zoom()
          .x(timelineXScale)
          .scaleExtent([1, 8])
          .on("zoom", zoomer);

        // For drag behavior in filters.
        var drag = d3.behavior.drag()
          // .origin(Object)
          .on("drag", dragger);

        timelineFourRiversYAxis.scale(timelineFourRiversYScale)
          .orient("left")
          .ticks(fourriversTicks)
          .tickFormat(d3.format("d"));
        timelineLeesFerryYAxis.scale(timelineLeesFerryYScale)
          .orient("left")
          .ticks(leesferryTicks)
          .tickFormat(d3.format("d"));
        timelinePNAYAxis.scale(timelinePNAYScale)
          .orient("left")
          .ticks(pnaTicks)
          .tickFormat(d3.format("d"));

        timelineXAxis.scale(timelineXScale)
          .orient("bottom")
          .tickFormat(d3.format("d"));

        var timelineFourRiversLine = d3.svg.line() // I think we're going to need this to be global.
          .x(function(d) { return timelineXScale(d["Year"]); })
          .y(function(d) { return timelineFourRiversYScale(d["FourRivers"]); });
        var timelineLeesFerryLine = d3.svg.line() // I think we're going to need this to be global.
          .x(function(d) { return timelineXScale(d["Year"]); })
          .y(function(d) { return timelineLeesFerryYScale(d["LeesFerry"]); });
        var timelinePNALine = d3.svg.line() // I think we're going to need this to be global.
          .x(function(d) { return timelineXScale(d["Year"]); })
          .y(function(d) { return timelinePNAYScale(d["PNA"]); });

        var timelineSvg = d3.select("#timeline-chart").append("svg")
          .attr("width", timelineWidth + timelineMargin.left + timelineMargin.right)
          .attr("heigh", timelineHeight + timelineMargin.top + timelineMargin.bottom);

        timelineSvg.append("g")
            .attr("id", "timelineplotspace")
            .attr("transform", "translate(" + timelineMargin.left + "," + timelineMargin.top + ")")
            .append("clipPath")
            .attr("id", "timeline-clip")
            .append("rect")
            .attr("cy", 0)
            .attr("cx", 0)
            .attr("height", timelineHeight)
            .attr("width", timelineWidth);

        timelineSvg.select("#timelineplotspace").append("g")
          .attr("class", "series fourrivers")
          .attr("transform", "translate(0," + seriespadding / 2 + ")")
          .append("g")
          .attr("class", "series chart");
        timelineSvg.select("#timelineplotspace").append("g")
          .attr("class", "series leesferry")
          .attr("transform", "translate(0," + (timelineHeight / noseries + (seriespadding / 2)) + ")")
          .append("g")
          .attr("class", "series chart");
        timelineSvg.select("#timelineplotspace").append("g")
          .attr("class", "series pna")
          .attr("transform", "translate(0," + ((timelineHeight / noseries * 2) + (seriespadding / 2)) + ")")
          .append("g")
          .attr("class", "series chart");

        timelineSvg.selectAll(".series.chart")
          .append("rect")
          .attr("cy", 0)
          .attr("cx", 0)
          .attr("height", serieschartHeight)
          .attr("width", timelineWidth)
          .attr("class", "series chart background");

        timelineSvg.select(".series.fourrivers").select(".chart")     
          .append("path")
          .attr("class", "lineplot lineplotpath fourrivers")
          .attr("d", timelineFourRiversLine(dataset));
        timelineSvg.select(".series.fourrivers").select(".chart").selectAll("circle")
          .data(dataset)
          .enter()
          .append("circle")
          .attr("class", "lineplot lineplotcircle fourrivers")
          .attr("cy", function(d) {
            return timelineFourRiversYScale(d["FourRivers"]);
          })
          .attr("cx", function(d) {
            return timelineXScale(d["Year"]);
          })
          .attr("r", 4)
          .append("title")
          .text(function(d) {
            return d["FourRivers"] + " (" + d["Year"] + ")";
          });

        timelineSvg.select(".series.leesferry").select(".chart")
          .append("path")
          .attr("class", "lineplot lineplotpath leesferry")
          .attr("d", timelineLeesFerryLine(dataset));
        timelineSvg.select(".series.leesferry").select(".chart").selectAll("circle")
          .data(dataset)
          .enter()
          .append("circle")
          .attr("class", "lineplot lineplotcircle leesferry")
          .attr("cy", function(d) {
            return timelineLeesFerryYScale(d["LeesFerry"]);
          })
          .attr("cx", function(d) {
            return timelineXScale(d["Year"]);
          })
          .attr("r", 4)
          .append("title")
          .text(function(d) {
            return d["LeesFerry"] + " (" + d["Year"] + ")";
          });

        timelineSvg.select(".series.pna").select(".chart")
          .append("path")
          .attr("class", "lineplot lineplotpath pna")
          .attr("d", timelinePNALine(dataset));
        timelineSvg.select(".series.pna").select(".chart").selectAll("circle")
          .data(dataset)
          .enter()
          .append("circle")
          .attr("class", "lineplot lineplotcircle pna")
          .attr("cy", function(d) {
            return timelinePNAYScale(d["PNA"]);
          })
          .attr("cx", function(d) {
            return timelineXScale(d["Year"]);
          })
          .attr("r", 4)
          .append("title")
          .text(function(d) {
            return d["PNA"] + " (" + d["Year"] + ")";
          });

        timelineSvg.select("#timelineplotspace").append("g")
          .attr("class", "axis x")
          .attr("transform", "translate(0," + timelineHeight + ")")
          .call(timelineXAxis);

        timelineSvg.select(".series.fourrivers").append("g")
          .attr("class", "axis y")
          .call(timelineFourRiversYAxis);
        timelineSvg.select(".series.leesferry").append("g")
          .attr("class", "axis y")
          .call(timelineLeesFerryYAxis);
        timelineSvg.select(".series.pna").append("g")
          .attr("class", "axis y")
          .call(timelinePNAYAxis);

        timelineSvg.selectAll(".series.chart")
          .attr("clip-path", "url(#timeline-clip)")
          .call(zoom);

        function zoomer() {
          // Called when zoom events are triggered. Transitions if zoom, not if panned.
          // console.log(d3.event.scale);  // DEBUG
          durationtime = 200;
          var t = d3.event.translate;
          var s = d3.event.scale;
          t[0] = Math.min(0, Math.max(timelineWidth * (1 - s), t[0]));      
          zoom.translate(t);
          if (s == previousScale) {
            timelineSvg.select("#timelineplotspace")
              .select(".axis.x")
              .call(timelineXAxis);
            timelineSvg.selectAll(".lineplotcircle")
              .attr("cx", function(d) {
                return timelineXScale(d["Year"]);
              });
            timelineSvg.select(".lineplotpath.fourrivers")
              .attr("d", timelineFourRiversLine(dataset));
            timelineSvg.select(".lineplotpath.leesferry")
              .attr("d", timelineLeesFerryLine(dataset));
            timelineSvg.select(".lineplotpath.pna")
              .attr("d", timelinePNALine(dataset));
          } else {
            timelineSvg.select("#timelineplotspace")
              .select(".axis.x")
              .transition()
              .duration(durationtime)
              .call(timelineXAxis);
            timelineSvg.selectAll(".lineplotcircle")
              .transition()
              .duration(durationtime)
              .attr("cx", function(d) {
                return timelineXScale(d["Year"]);
              });
            timelineSvg.select(".lineplotpath.fourrivers")
              .transition()
              .duration(durationtime)
              .attr("d", timelineFourRiversLine(dataset));
            timelineSvg.select(".lineplotpath.leesferry")
              .transition()
              .duration(durationtime)
              .attr("d", timelineLeesFerryLine(dataset));
            timelineSvg.select(".lineplotpath.pna")
              .transition()
              .duration(durationtime)
              .attr("d", timelinePNALine(dataset));
          }
          previousScale = d3.event.scale;
        }

        // Plot for defining filters.
        var filterMargin = {top: 20, right: 50, bottom: 20, left: 50};
        var filterWidth = 260 - filterMargin.left - filterMargin.right;
        var filterHeight = 300 - filterMargin.top - filterMargin.bottom;
        var filterXScale = d3.scale.linear();
        var filterXAxis = d3.svg.axis();
        var filterSvg = d3.select("#filter-chart").append("svg")
          .attr("width", filterWidth + filterMargin.left + filterMargin.right)
          .attr("heigh", filterHeight + filterMargin.top + filterMargin.bottom);
        filterXScale.domain([d3.min(lookup.filters, function(d) { return d["filterYear"]; }),
                    d3.max(lookup.filters, function(d) { return d["filterYear"]; })])
          .range([0, filterWidth])
          .nice(filterXAxisTicks);

        filterXAxis.scale(filterXScale)
          .ticks(filterXAxisTicks)
          .orient("bottom")
          .tickFormat(d3.format("d"));

        filterSvg.append("g")
            .attr("id", "filterplotspace")
            .attr("transform", "translate(" + filterMargin.left + "," + filterMargin.top + ")")
            .append("clipPath")
            .attr("id", "filter-clip")
            .append("rect")
            .attr("cy", 0)
            .attr("cx", 0)
            .attr("height", filterHeight)
            .attr("width", filterWidth);

        filterSvg.select("#filterplotspace").append("g")
          .attr("class", "series fourrivers")
          .attr("transform", "translate(0," + seriespadding / 2 + ")")
          .append("g")
          .attr("class", "chart filter");
        filterSvg.select("#filterplotspace").append("g")
          .attr("class", "series leesferry")
          .attr("transform", "translate(0," + (filterHeight / noseries + (seriespadding / 2)) + ")")
          .append("g")
          .attr("class", "chart filter");
        filterSvg.select("#filterplotspace").append("g")
          .attr("class", "series pna")
          .attr("transform", "translate(0," + ((filterHeight / noseries * 2) + (seriespadding / 2)) + ")")
          .append("g")
          .attr("class", "chart filter");

        filterSvg.selectAll(".filter.chart")
          .append("rect")
          .attr("cy", 0)
          .attr("cx", 0)
          .attr("height", serieschartHeight)
          .attr("width", filterWidth)
          .attr("class", "filter chart background");

        // Adding the connecting line between circles for the filters chart.
        filterSvg.select(".series.fourrivers").select(".chart").selectAll("line")
          .data(lookup.filters)
          .enter()
          .append("line")
          .attr("class", "filter filterplotline fourrivers")
          .attr("y1", function(d) {
            return timelineFourRiversYScale(d["FourRivers"].low);
          })
          .attr("x2", function(d) {
            return filterXScale(d["filterYear"]);
          })
          .attr("y2", function(d) {
            return timelineFourRiversYScale(d["FourRivers"].high);
          })
          .attr("x1", function(d) {
            return filterXScale(d["filterYear"]);
          });
        filterSvg.select(".series.leesferry").select(".chart").selectAll("line")
          .data(lookup.filters)
          .enter()
          .append("line")
          .attr("class", "filter filterplotline leesferry")
          .attr("y1", function(d) {
            return timelineLeesFerryYScale(d["LeesFerry"].low);
          })
          .attr("x1", function(d) {
            return filterXScale(d["filterYear"]);
          })
          .attr("y2", function(d) {
            return timelineLeesFerryYScale(d["LeesFerry"].high);
          })
          .attr("x2", function(d) {
            return filterXScale(d["filterYear"]);
          });
        filterSvg.select(".series.pna").select(".chart").selectAll("line")
          .data(lookup.filters)
          .enter()
          .append("line")
          .attr("class", "filter filterplotline pna")
          .attr("y1", function(d) {
            return timelinePNAYScale(d["PNA"].low);
          })
          .attr("x1", function(d) {
            return filterXScale(d["filterYear"]);
          })
          .attr("y2", function(d) {
            return timelinePNAYScale(d["PNA"].high);
          })
          .attr("x2", function(d) {
            return filterXScale(d["filterYear"]);
          });

        // Adding the upper bounds circle for the filters chart.
        filterSvg.select(".series.fourrivers").select(".chart").selectAll("circle.high")
          .data(lookup.filters)
          .enter()
          .append("circle")
          .attr("class", "filter filterplotcircle fourrivers high")
          .attr("cy", function(d) {
            return timelineFourRiversYScale(d["FourRivers"].high);
          })
          .attr("cx", function(d) {
            return filterXScale(d["filterYear"]);
          })
          .attr("r", 4)
          .append("title")
          .text(function(d) {
            return d["FourRivers"].high + " (" + d["filterYear"] + ")";
          });
        filterSvg.select(".series.leesferry").select(".chart").selectAll("circle.high")
          .data(lookup.filters)
          .enter()
          .append("circle")
          .attr("class", "filter filterplotcircle leesferry high")
          .attr("cy", function(d) {
            return timelineLeesFerryYScale(d["LeesFerry"].high);
          })
          .attr("cx", function(d) {
            return filterXScale(d["filterYear"]);
          })
          .attr("r", 4)
          .append("title")
          .text(function(d) {
            return d["LeesFerry"].high + " (" + d["filterYear"] + ")";
          });
        filterSvg.select(".series.pna").select(".chart").selectAll("circle.high")
          .data(lookup.filters)
          .enter()
          .append("circle")
          .attr("class", "filter filterplotcircle pna high")
          .attr("cy", function(d) {
            return timelinePNAYScale(d["PNA"].high);
          })
          .attr("cx", function(d) {
            return filterXScale(d["filterYear"]);
          })
          .attr("r", 4)
          .append("title")
          .text(function(d) {
            return d["PNA"].high + " (" + d["filterYear"] + ")";
          });

        // Adding the lower bounds circles for the filters chart.
        filterSvg.select(".series.fourrivers").select(".chart").selectAll("circle.low")
          .data(lookup.filters)
          .enter()
          .append("circle")
          .attr("class", "filter filterplotcircle fourrivers low")
          .attr("cy", function(d) {
            return timelineFourRiversYScale(d["FourRivers"].low);
          })
          .attr("cx", function(d) {
            return filterXScale(d["filterYear"]);
          })
          .attr("r", 4)
          .append("title")
          .text(function(d) {
            return d["FourRivers"].low + " (" + d["filterYear"] + ")";
          });
        filterSvg.select(".series.leesferry").select(".chart").selectAll("circle.low")
          .data(lookup.filters)
          .enter()
          .append("circle")
          .attr("class", "filter filterplotcircle leesferry low")
          .attr("cy", function(d) {
            return timelineLeesFerryYScale(d["LeesFerry"].low);
          })
          .attr("cx", function(d) {
            return filterXScale(d["filterYear"]);
          })
          .attr("r", 4)
          .append("title")
          .text(function(d) {
            return d["LeesFerry"].low + " (" + d["filterYear"] + ")";
          });
        filterSvg.select(".series.pna").select(".chart").selectAll("circle.low")
          .data(lookup.filters)
          .enter()
          .append("circle")
          .attr("class", "filter filterplotcircle pna low")
          .attr("cy", function(d) {
            return timelinePNAYScale(d["PNA"].low);
          })
          .attr("cx", function(d) {
            return filterXScale(d["filterYear"]);
          })
          .attr("r", 4)
          .append("title")
          .text(function(d) {
            return d["PNA"].low + " (" + d["filterYear"] + ")";
          });

        filterSvg.select("#filterplotspace").append("g")
          .attr("class", "axis x")
          .attr("transform", "translate(0," + filterHeight + ")")
          .call(filterXAxis);

        filterSvg.selectAll(".filterplotcircle")
          .call(drag);

        function dragger(d) {
          // Called whenever drag events are fired. Intended to work on filterSvg circles.
          // TODO: Check for which series to return back to is a bit hackish. Consider this when redoing the data design.
          if (d3.select(this).attr("class").indexOf("fourrivers") !== -1) {
            if (d3.select(this).attr("class").indexOf("high") !== -1) {
              lookup.setHighFilter(timelineFourRiversYScale.invert(parseFloat(d3.event.y)), "FourRivers", d.filterYear);
              filterSvg.select(".series.fourrivers").select(".chart").selectAll("circle.high")
                .attr("cy", function(d) {
                  return timelineFourRiversYScale(d["FourRivers"].high);
                })
                .attr("cx", function(d) {
                  return filterXScale(d["filterYear"]);
                })
                .select("title")
                .text(function(d) {
                  return d["FourRivers"].high + " (" + d["filterYear"] + ")";
                });
              filterSvg.select(".series.fourrivers").select(".chart").selectAll("line")
                .attr("y1", function(d) {
                  return timelineFourRiversYScale(d["FourRivers"].low);
                })
                .attr("x2", function(d) {
                  return filterXScale(d["filterYear"]);
                })
                .attr("y2", function(d) {
                  return timelineFourRiversYScale(d["FourRivers"].high);
                })
                .attr("x1", function(d) {
                  return filterXScale(d["filterYear"]);
                });
            } else if (d3.select(this).attr("class").indexOf("low") !== -1) {
              lookup.setLowFilter(timelineFourRiversYScale.invert(parseFloat(d3.event.y)), "FourRivers", d.filterYear);
              filterSvg.select(".series.fourrivers").select(".chart").selectAll("circle.low")
                .attr("cy", function(d) {
                  return timelineFourRiversYScale(d["FourRivers"].low);
                })
                .attr("cx", function(d) {
                  return filterXScale(d["filterYear"]);
                })
                .select("title")
                .text(function(d) {
                  return d["FourRivers"].low + " (" + d["filterYear"] + ")";
                });
              filterSvg.select(".series.fourrivers").select(".chart").selectAll("line")
                .attr("y1", function(d) {
                  return timelineFourRiversYScale(d["FourRivers"].low);
                })
                .attr("x2", function(d) {
                  return filterXScale(d["filterYear"]);
                })
                .attr("y2", function(d) {
                  return timelineFourRiversYScale(d["FourRivers"].high);
                })
                .attr("x1", function(d) {
                  return filterXScale(d["filterYear"]);
                });         
            }
          } else if (d3.select(this).attr("class").indexOf("leesferry") !== -1) {
            if (d3.select(this).attr("class").indexOf("high") !== -1) {
              lookup.setHighFilter(timelineLeesFerryYScale.invert(parseFloat(d3.event.y)), "LeesFerry", d.filterYear);
              filterSvg.select(".series.leesferry").select(".chart").selectAll("circle.high")
                .attr("cy", function(d) {
                  return timelineLeesFerryYScale(d["LeesFerry"].high);
                })
                .attr("cx", function(d) {
                  return filterXScale(d["filterYear"]);
                })
                .select("title")
                .text(function(d) {
                  return d["LeesFerry"].high + " (" + d["filterYear"] + ")";
                });
              filterSvg.select(".series.leesferry").select(".chart").selectAll("line")
                .attr("y1", function(d) {
                  return timelineLeesFerryYScale(d["LeesFerry"].low);
                })
                .attr("x2", function(d) {
                  return filterXScale(d["filterYear"]);
                })
                .attr("y2", function(d) {
                  return timelineLeesFerryYScale(d["LeesFerry"].high);
                })
                .attr("x1", function(d) {
                  return filterXScale(d["filterYear"]);
                });
            } else if (d3.select(this).attr("class").indexOf("low") !== -1) {
              lookup.setLowFilter(timelineLeesFerryYScale.invert(parseFloat(d3.event.y)), "LeesFerry", d.filterYear);
              filterSvg.select(".series.leesferry").select(".chart").selectAll("circle.low")
                .attr("cy", function(d) {
                  return timelineLeesFerryYScale(d["LeesFerry"].low);
                })
                .attr("cx", function(d) {
                  return filterXScale(d["filterYear"]);
                })
                .select("title")
                .text(function(d) {
                  return d["LeesFerry"].low + " (" + d["filterYear"] + ")";
                });
              filterSvg.select(".series.leesferry").select(".chart").selectAll("line")
                .attr("y1", function(d) {
                  return timelineLeesFerryYScale(d["LeesFerry"].low);
                })
                .attr("x2", function(d) {
                  return filterXScale(d["filterYear"]);
                })
                .attr("y2", function(d) {
                  return timelineLeesFerryYScale(d["LeesFerry"].high);
                })
                .attr("x1", function(d) {
                  return filterXScale(d["filterYear"]);
                });         
            }
          } else if (d3.select(this).attr("class").indexOf("pna") !== -1) {
            if (d3.select(this).attr("class").indexOf("high") !== -1) {
              lookup.setHighFilter(timelinePNAYScale.invert(parseFloat(d3.event.y)), "PNA", d.filterYear);
              filterSvg.select(".series.pna").select(".chart").selectAll("circle.high")
                .attr("cy", function(d) {
                  return timelinePNAYScale(d["PNA"].high);
                })
                .attr("cx", function(d) {
                  return filterXScale(d["filterYear"]);
                })
                .select("title")
                .text(function(d) {
                  return d["PNA"].high + " (" + d["filterYear"] + ")";
                });
              filterSvg.select(".series.pna").select(".chart").selectAll("line")
                .attr("y1", function(d) {
                  return timelinePNAYScale(d["PNA"].low);
                })
                .attr("x2", function(d) {
                  return filterXScale(d["filterYear"]);
                })
                .attr("y2", function(d) {
                  return timelinePNAYScale(d["PNA"].high);
                })
                .attr("x1", function(d) {
                  return filterXScale(d["filterYear"]);
                });
            } else if (d3.select(this).attr("class").indexOf("low") !== -1) {
              lookup.setLowFilter(timelinePNAYScale.invert(parseFloat(d3.event.y)), "PNA", d.filterYear);
              filterSvg.select(".series.pna").select(".chart").selectAll("circle.low")
                .attr("cy", function(d) {
                  return timelinePNAYScale(d["PNA"].low);
                })
                .attr("cx", function(d) {
                  return filterXScale(d["filterYear"]);
                })
                .select("title")
                .text(function(d) {
                  return d["PNA"].low + " (" + d["filterYear"] + ")";
                });
              filterSvg.select(".series.pna").select(".chart").selectAll("line")
                .attr("y1", function(d) {
                  return timelinePNAYScale(d["PNA"].low);
                })
                .attr("x2", function(d) {
                  return filterXScale(d["filterYear"]);
                })
                .attr("y2", function(d) {
                  return timelinePNAYScale(d["PNA"].high);
                })
                .attr("x1", function(d) {
                  return filterXScale(d["filterYear"]);
                });         
            }
          } else {
            alert("Something went wrong with filter dragging.");
          }
          refilter();
        }

        filterSvg.select(".series.fourrivers").append("g")
          .attr("class", "axis y")
          .call(timelineFourRiversYAxis);
        filterSvg.select(".series.leesferry").append("g")
          .attr("class", "axis y")
          .call(timelineLeesFerryYAxis);
        filterSvg.select(".series.pna").append("g")
          .attr("class", "axis y")
          .call(timelinePNAYAxis);

        filterSvg.selectAll(".filter.chart")
          .attr("clip-path", "url(#filter-clip)");

        // Results single-year histogram.
        initYearhistData();
        var yearhistMargin = {top: 20, right: 50, bottom: 20, left: 50};
        var yearhistWidth = 260 - yearhistMargin.left - yearhistMargin.right;
        var yearhistHeight = 300 - yearhistMargin.top - yearhistMargin.bottom;
        var yearhistXScale = d3.scale.linear();
        var yearhistSvg = d3.select("#yearhist-chart").append("svg")
          .attr("width", yearhistWidth + yearhistMargin.left + yearhistMargin.right)
          .attr("heigh", yearhistHeight + yearhistMargin.top + yearhistMargin.bottom);
        var yearhistXAxis = d3.svg.axis();
        yearhistXScale.domain([0, lookup.dataset.length])
                    .range([0, yearhistWidth])
                    .nice();

        yearhistXAxis.scale(yearhistXScale)
          .orient("bottom")
          .tickFormat(d3.format("d"));

        yearhistSvg.append("g")
            .attr("id", "yearhistplotspace")
            .attr("transform", "translate(" + yearhistMargin.left + "," + yearhistMargin.top + ")")
            .append("clipPath")
            .attr("id", "yearhist-clip")
            .append("rect")
            .attr("cy", 0)
            .attr("cx", 0)
            .attr("height", yearhistHeight)
            .attr("width", yearhistWidth);

        yearhistSvg.select("#yearhistplotspace").append("g")
          .attr("class", "series fourrivers")
          .attr("transform", "translate(0," + seriespadding / 2 + ")")
          .append("g")
          .attr("class", "chart yearhist");
        yearhistSvg.select("#yearhistplotspace").append("g")
          .attr("class", "series leesferry")
          .attr("transform", "translate(0," + (yearhistHeight / noseries + (seriespadding / 2)) + ")")
          .append("g")
          .attr("class", "chart yearhist");
        yearhistSvg.select("#yearhistplotspace").append("g")
          .attr("class", "series pna")
          .attr("transform", "translate(0," + ((yearhistHeight / noseries * 2) + (seriespadding / 2)) + ")")
          .append("g")
          .attr("class", "chart yearhist");

        yearhistSvg.selectAll(".yearhist.chart")
          .append("rect")
          .attr("cy", 0)
          .attr("cx", 0)
          .attr("height", serieschartHeight)
          .attr("width", yearhistWidth)
          .attr("class", "yearhist chart background");

        yearhistSvg.select(".series.fourrivers").select(".chart").selectAll(".bar")
          .data(yearhistData.FourRivers)
          .enter()
          .append("rect")
          .attr("class", "yearhist yearhistplotrect fourrivers")
          .attr("y", function(d) { return timelineFourRiversYScale(d.x + d.dx);
          })      
          .attr("x", 0)
          .attr("height", function(d) {
            return timelineFourRiversYScale(d.x) - timelineFourRiversYScale(d.dx + d.x);
          })
          .attr("width", 0)
          .append("title")
          .text(function(d) {
            return d.y + " events (" + d.x + " - " + (d.x + d.dx) + ")";
          });


        yearhistSvg.select(".series.leesferry").select(".chart").selectAll(".bar")
          .data(yearhistData.LeesFerry)
          .enter()
          .append("rect")
          .attr("class", "yearhist yearhistplotrect leesferry")
          .attr("y", function(d) { return timelineLeesFerryYScale(d.x + d.dx);
          })
          .attr("x", 0)
          .attr("height", function(d) {
            return timelineLeesFerryYScale(d.x) - timelineLeesFerryYScale(d.dx + d.x);
          })
          .attr("width", 0)
          .append("title")
          .text(function(d) {
            return d.y + " events (" + d.x + " - " + (d.x + d.dx) + ")";
          });

        yearhistSvg.select(".series.pna").select(".chart").selectAll(".bar")
          .data(yearhistData.PNA)
          .enter()
          .append("rect")
          .attr("class", "yearhist yearhistplotrect pna")
          .attr("y", function(d) { return timelinePNAYScale(d.x + d.dx);
          })
          .attr("x", 0)
          .attr("height", function(d) {
            return timelinePNAYScale(d.x) - timelinePNAYScale(d.dx + d.x);
          })
          .attr("width", 0)
          .append("title")
          .text(function(d) {
            return d.y + " events (" + d.x + " - " + (d.x + d.dx) + ")";
          });

        yearhistSvg.select(".series.fourrivers").append("g")
          .attr("class", "axis y")
          .call(timelineFourRiversYAxis);
        yearhistSvg.select(".series.leesferry").append("g")
          .attr("class", "axis y")
          .call(timelineLeesFerryYAxis);
        yearhistSvg.select(".series.pna").append("g")
          .attr("class", "axis y")
          .call(timelinePNAYAxis);

        yearhistSvg.select("#yearhistplotspace").append("g")
          .attr("class", "axis x")
          .attr("transform", "translate(0," + yearhistHeight + ")")
          .call(yearhistXAxis);

        yearhistSvg.selectAll(".filter.chart")
          .attr("clip-path", "url(#filter-clip)");

        function refreshYearhist(m) {
          // Refresh the single year histogram given `m`, an array, like 
          //`lookup.dataset`, which has an object for each target
          // -not matched- year.

          yearhistData.FourRivers = d3.layout.histogram()
            .bins(timelineFourRiversYScale.ticks(fourriversTicks))
            (m.map(function(d) { return d.FourRivers; }));
          yearhistData.LeesFerry = d3.layout.histogram()
            .bins(timelineLeesFerryYScale.ticks(leesferryTicks))
            (m.map(function(d) { return d.LeesFerry; }));
          yearhistData.PNA = d3.layout.histogram()
            .bins(timelinePNAYScale.ticks(pnaTicks))
            (m.map(function(d) { return d.PNA; }));

          // OOoo, sexy.
          yearhistXScale.domain([0, d3.max([d3.max(yearhistData.FourRivers.map(function(d){return d.y;})),
                                                  d3.max(yearhistData.LeesFerry.map(function(d){return d.y;})),
                                                  d3.max(yearhistData.PNA.map(function(d){return d.y;}))])]);

          yearhistXAxis.scale(yearhistXScale);
          yearhistSvg.select("#yearhistplotspace").selectAll(".axis.x")
            .call(yearhistXAxis);

          yearhistSvg.selectAll(".fourrivers.yearhistplotrect")
            .data(yearhistData.FourRivers)
            .attr("width", function(d) {
              return yearhistXScale(d.y);
            })
            .select("title")
            .text(function(d) {
              return d.y + " events (" + d.x + " to " + (d.x + d.dx) + ")";
            });
          yearhistSvg.selectAll(".leesferry.yearhistplotrect")
            .data(yearhistData.LeesFerry)
            .attr("width", function(d) {
              return yearhistXScale(d.y);
            })
            .select("title")
            .text(function(d) {
              return d.y + " events (" + d.x + " to " + (d.x + d.dx) + ")";
            });       
          yearhistSvg.selectAll(".pna.yearhistplotrect")
            .data(yearhistData.PNA)
            .attr("width", function(d) {
              return yearhistXScale(d.y);
            })
            .select("title")
            .text(function(d) {
              return d.y + " events (" + d.x + " to " + (d.x + d.dx) + ")";
            });       
        }

          function refilter() {
            // Rerun the lookup filter engine and refresh plots as needed.
            var matched = lookup.getMatchArray();
            highlightYears(matched.map(function(d) { return d.Year; }));
            refreshYearhist(matched);
          }

      });

      // console.log(dataset); // DEBUG
      </script>
  </body>
</html>